<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebSocket API Documentation - Nounberg Terminal</title>
  <style>
    :root {
      --primary-color: #3b82f6;
      --secondary-color: #1e40af;
      --text-color: #333;
      --code-bg: #f1f5f9;
      --border-color: #e5e7eb;
    }
    
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
      line-height: 1.6;
      color: var(--text-color);
      max-width: 1000px;
      margin: 0 auto;
      padding: 20px;
    }
    
    h1 {
      font-size: 2.5rem;
      margin-bottom: 1rem;
      color: var(--primary-color);
      border-bottom: 1px solid var(--border-color);
      padding-bottom: 0.5rem;
    }
    
    h2 {
      font-size: 1.8rem;
      margin-top: 2rem;
      margin-bottom: 1rem;
      color: var(--secondary-color);
    }
    
    h3 {
      font-size: 1.3rem;
      margin-top: 1.5rem;
      margin-bottom: 0.5rem;
    }
    
    p {
      margin-bottom: 1rem;
    }
    
    ul, ol {
      margin-bottom: 1rem;
      padding-left: 1.5rem;
    }
    
    li {
      margin-bottom: 0.5rem;
    }
    
    code {
      font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
      padding: 0.2rem 0.4rem;
      background-color: var(--code-bg);
      border-radius: 3px;
      font-size: 0.9rem;
    }
    
    pre {
      background-color: var(--code-bg);
      padding: 1rem;
      border-radius: 5px;
      overflow-x: auto;
      margin-bottom: 1rem;
    }
    
    pre code {
      padding: 0;
      background-color: transparent;
    }
    
    .header-anchor {
      margin-left: 0.5rem;
      font-size: 1rem;
      text-decoration: none;
      opacity: 0.5;
    }
    
    .header-anchor:hover {
      opacity: 1;
    }
    
    .endpoint {
      margin-bottom: 2rem;
      padding: 1rem;
      border: 1px solid var(--border-color);
      border-radius: 5px;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: 1rem;
    }
    
    th, td {
      padding: 0.5rem;
      text-align: left;
      border: 1px solid var(--border-color);
    }
    
    th {
      background-color: #f8fafc;
    }

    .interactive-demo {
      margin: 2rem 0;
      padding: 1.5rem;
      background-color: #f8fafc;
      border-radius: 5px;
      border: 1px solid var(--border-color);
    }

    .demo-controls {
      display: flex;
      gap: 1rem;
      margin-bottom: 1rem;
    }

    .demo-controls button {
      padding: 0.5rem 1rem;
      background-color: var(--primary-color);
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 1rem;
    }

    .demo-controls button:hover {
      background-color: var(--secondary-color);
    }

    .demo-controls button:disabled {
      background-color: #94a3b8;
      cursor: not-allowed;
    }

    .demo-log {
      background-color: #1e293b;
      color: #f8fafc;
      padding: 1rem;
      border-radius: 4px;
      min-height: 200px;
      max-height: 400px;
      overflow-y: auto;
      font-family: monospace;
    }

    .demo-log p {
      margin: 0;
      line-height: 1.5;
    }

    .demo-log .timestamp {
      color: #94a3b8;
      margin-right: 0.5rem;
    }

    .demo-log .receive {
      color: #a5f3fc;
    }

    .demo-log .send {
      color: #bef264;
    }

    .demo-log .error {
      color: #fda4af;
    }

    /* Dark mode */
    @media (prefers-color-scheme: dark) {
      :root {
        --primary-color: #3b82f6;
        --secondary-color: #60a5fa;
        --text-color: #e5e7eb;
        --code-bg: #1e293b;
        --border-color: #374151;
      }
      
      body {
        background-color: #0f172a;
      }
      
      th {
        background-color: #1e293b;
      }
      
      .interactive-demo {
        background-color: #1e293b;
      }
    }

    .back-link {
      display: inline-block;
      margin-bottom: 2rem;
      color: var(--primary-color);
      text-decoration: none;
    }

    .back-link:hover {
      text-decoration: underline;
    }
  </style>
</head>
<body>
  <a href="/docs" class="back-link">← Back to main documentation</a>

  <h1>WebSocket API Documentation</h1>
  <p>
    The Nounberg Terminal provides real-time auction events through a WebSocket connection.
    This page explains how to use the WebSocket API to receive real-time updates.
  </p>

  <h2 id="connection">Connection <a href="#connection" class="header-anchor">#</a></h2>
  <p>
    Connect to the WebSocket endpoint at:
  </p>
  <pre><code>ws://your-server-domain.com/ws</code></pre>
  <p>
    When using secure connections:
  </p>
  <pre><code>wss://your-server-domain.com/ws</code></pre>

  <h2 id="message-format">Message Format <a href="#message-format" class="header-anchor">#</a></h2>
  <p>
    All messages exchanged between client and server are JSON objects with a <code>type</code> field
    that indicates the message type.
  </p>

  <h3>Client to Server Messages</h3>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
        <th>Payload</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>subscribe</code></td>
        <td>Subscribe to auction events</td>
        <td>None</td>
      </tr>
      <tr>
        <td><code>pong</code></td>
        <td>Response to server ping</td>
        <td>None</td>
      </tr>
    </tbody>
  </table>

  <h3>Server to Client Messages</h3>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
        <th>Payload</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>welcome</code></td>
        <td>Sent when client connects</td>
        <td><code>message</code>: Welcome message</td>
      </tr>
      <tr>
        <td><code>subscribed</code></td>
        <td>Confirmation of subscription</td>
        <td>None</td>
      </tr>
      <tr>
        <td><code>event</code></td>
        <td>New auction event</td>
        <td><code>data</code>: Event object</td>
      </tr>
      <tr>
        <td><code>ping</code></td>
        <td>Heartbeat to keep connection alive</td>
        <td>None</td>
      </tr>
    </tbody>
  </table>

  <h2 id="workflow">Connection Workflow <a href="#workflow" class="header-anchor">#</a></h2>
  <ol>
    <li>Client establishes WebSocket connection</li>
    <li>Server sends <code>welcome</code> message</li>
    <li>Client sends <code>subscribe</code> message</li>
    <li>Server sends <code>subscribed</code> confirmation</li>
    <li>Server sends <code>event</code> messages as new auction events occur</li>
    <li>Server periodically sends <code>ping</code> messages</li>
    <li>Client responds with <code>pong</code> messages</li>
  </ol>

  <h2 id="event-object">Event Object <a href="#event-object" class="header-anchor">#</a></h2>
  <p>
    The <code>event</code> message contains a <code>data</code> field with an event object:
  </p>
  <pre><code>{
  "type": "event",
  "data": {
    "id": "0x1234567890abcdef...",
    "blockNumber": 12345678,
    "blockHash": "0xabcdef1234567890...",
    "transactionHash": "0x0987654321fedcba...",
    "type": "AuctionSettled", // One of: "AuctionCreated", "AuctionBid", "AuctionSettled"
    "nounId": 721,
    "value": "69.42", // ETH amount
    "valueUsd": "248000", // USD equivalent
    "bidder": "0x1234...", // Ethereum address (for AuctionBid)
    "bidderEns": "vitalik.eth", // ENS name if available
    "winner": "0x1234...", // Ethereum address (for AuctionSettled)
    "winnerEns": "vitalik.eth", // ENS name if available
    "thumbnailUrl": "https://noun.pics/721",
    "headline": "Noun #721 sold for 69.42 Ξ ($248,000) to vitalik.eth",
    "createdAt": 1684375624 // Unix timestamp
  }
}</code></pre>

  <h2 id="example">Example Usage <a href="#example" class="header-anchor">#</a></h2>
  <pre><code>// Create WebSocket connection
const socket = new WebSocket('ws://your-server-domain.com/ws');

socket.onopen = () => {
  console.log('Connected to WebSocket');
  
  // Subscribe to events
  socket.send(JSON.stringify({ type: 'subscribe' }));
};

socket.onmessage = (event) => {
  const data = JSON.parse(event.data);
  
  switch (data.type) {
    case 'welcome':
      console.log('Server says:', data.message);
      break;
      
    case 'subscribed':
      console.log('Successfully subscribed to events');
      break;
      
    case 'event':
      console.log('New auction event:', data.data);
      // Handle the event data
      break;
      
    case 'ping':
      // Respond with pong to keep connection alive
      socket.send(JSON.stringify({ type: 'pong' }));
      break;
      
    default:
      console.log('Unknown message type:', data);
  }
};

socket.onclose = (event) => {
  console.log('Connection closed:', event.code, event.reason);
};

socket.onerror = (error) => {
  console.error('WebSocket error:', error);
};</code></pre>

  <h2 id="reconnection">Reconnection Strategy <a href="#reconnection" class="header-anchor">#</a></h2>
  <p>
    WebSocket connections can be disrupted for various reasons. Implement a reconnection
    strategy with exponential backoff:
  </p>
  <pre><code>function connect() {
  const socket = new WebSocket('ws://your-server-domain.com/ws');
  
  // ... handle socket events ...
  
  socket.onclose = (event) => {
    console.log('Connection closed:', event.code, event.reason);
    
    // Don't reconnect if closed normally
    if (event.code !== 1000) {
      // Exponential backoff
      const timeout = Math.min(1000 * Math.pow(2, reconnectAttempts), 30000);
      console.log(`Reconnecting in ${timeout}ms...`);
      
      setTimeout(() => {
        reconnectAttempts++;
        connect();
      }, timeout);
    }
  };
}</code></pre>

  <h2 id="demo">Interactive Demo <a href="#demo" class="header-anchor">#</a></h2>
  <div class="interactive-demo">
    <div class="demo-controls">
      <button id="connect-btn">Connect</button>
      <button id="subscribe-btn" disabled>Subscribe</button>
      <button id="disconnect-btn" disabled>Disconnect</button>
    </div>
    
    <div class="demo-log" id="demo-log"></div>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const connectBtn = document.getElementById('connect-btn');
      const subscribeBtn = document.getElementById('subscribe-btn');
      const disconnectBtn = document.getElementById('disconnect-btn');
      const demoLog = document.getElementById('demo-log');
      
      let socket = null;
      let reconnectAttempts = 0;
      
      function log(message, type = '') {
        const timestamp = new Date().toISOString().substr(11, 8);
        const p = document.createElement('p');
        p.innerHTML = `<span class="timestamp">[${timestamp}]</span> <span class="${type}">${message}</span>`;
        demoLog.appendChild(p);
        demoLog.scrollTop = demoLog.scrollHeight;
      }
      
      function connect() {
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const host = window.location.host;
        const wsUrl = `${protocol}//${host}/ws`;
        
        log(`Connecting to ${wsUrl}...`);
        
        try {
          socket = new WebSocket(wsUrl);
          
          socket.onopen = () => {
            log('Connected to WebSocket', 'receive');
            connectBtn.disabled = true;
            subscribeBtn.disabled = false;
            disconnectBtn.disabled = false;
            reconnectAttempts = 0;
          };
          
          socket.onmessage = (event) => {
            try {
              const data = JSON.parse(event.data);
              
              switch (data.type) {
                case 'welcome':
                  log(`Server: ${data.message}`, 'receive');
                  break;
                  
                case 'subscribed':
                  log('Successfully subscribed to events', 'receive');
                  break;
                  
                case 'event':
                  log(`New event: ${data.data.headline}`, 'receive');
                  break;
                  
                case 'ping':
                  log('Received ping, sending pong', 'receive');
                  socket.send(JSON.stringify({ type: 'pong' }));
                  break;
                  
                default:
                  log(`Received: ${event.data}`, 'receive');
              }
            } catch (err) {
              log(`Error parsing message: ${err.message}`, 'error');
            }
          };
          
          socket.onclose = (event) => {
            log(`Connection closed: code=${event.code} reason=${event.reason || 'No reason provided'}`, 'error');
            connectBtn.disabled = false;
            subscribeBtn.disabled = true;
            disconnectBtn.disabled = true;
            
            if (event.code !== 1000 && reconnectAttempts < 3) {
              const timeout = Math.min(1000 * Math.pow(2, reconnectAttempts), 5000);
              log(`Reconnecting in ${timeout}ms...`);
              
              setTimeout(() => {
                reconnectAttempts++;
                connect();
              }, timeout);
            }
          };
          
          socket.onerror = (error) => {
            log('WebSocket error', 'error');
          };
        } catch (err) {
          log(`Connection error: ${err.message}`, 'error');
          connectBtn.disabled = false;
          subscribeBtn.disabled = true;
          disconnectBtn.disabled = true;
        }
      }
      
      connectBtn.addEventListener('click', () => {
        connect();
      });
      
      subscribeBtn.addEventListener('click', () => {
        if (socket && socket.readyState === WebSocket.OPEN) {
          const message = JSON.stringify({ type: 'subscribe' });
          socket.send(message);
          log(`Sent: ${message}`, 'send');
        } else {
          log('Socket not connected', 'error');
        }
      });
      
      disconnectBtn.addEventListener('click', () => {
        if (socket) {
          socket.close(1000, 'User initiated disconnect');
          log('Disconnected by user');
          connectBtn.disabled = false;
          subscribeBtn.disabled = true;
          disconnectBtn.disabled = true;
        }
      });
    });
  </script>
  
  <footer style="margin-top: 3rem; padding-top: 1rem; border-top: 1px solid var(--border-color); text-align: center; font-size: 0.9rem; color: #666;">
    <p>Nounberg Terminal WebSocket API Documentation © 2025</p>
  </footer>
</body>
</html>
