import { ShutdownError } from '../internal/errors.js';
import { createQueue } from './queue.js';
import { getLogsRetryHelper, } from "@ponder/utils";
import { HttpRequestError, JsonRpcVersionUnsupportedError, MethodNotFoundRpcError, MethodNotSupportedRpcError, ParseRpcError, isHex, } from "viem";
import { startClock } from "./timer.js";
import { wait } from "./wait.js";
const RETRY_COUNT = 9;
const BASE_DURATION = 125;
/**
 * Creates a queue to manage rpc requests.
 */
export const createRequestQueue = ({ common, network, concurrency = 25, }) => {
    // @ts-ignore
    const fetchRequest = async (request) => {
        for (let i = 0; i <= RETRY_COUNT; i++) {
            try {
                const stopClock = startClock();
                if (common.shutdown.isKilled) {
                    throw new ShutdownError();
                }
                common.logger.trace({
                    service: "rpc",
                    msg: `Sent ${request.method} request (params=${JSON.stringify(request.params)})`,
                });
                const response = await network.transport.request(request);
                common.metrics.ponder_rpc_request_duration.observe({ method: request.method, network: network.name }, stopClock());
                if (common.shutdown.isKilled) {
                    throw new ShutdownError();
                }
                common.logger.trace({
                    service: "rpc",
                    msg: `Received ${request.method} response (duration=${stopClock()}, params=${JSON.stringify(request.params)})`,
                });
                return response;
            }
            catch (_error) {
                const error = _error;
                if (common.shutdown.isKilled) {
                    throw new ShutdownError();
                }
                if (request.method === "eth_getLogs" &&
                    isHex(request.params[0].fromBlock) &&
                    isHex(request.params[0].toBlock)) {
                    const getLogsErrorResponse = getLogsRetryHelper({
                        params: request.params,
                        error: error,
                    });
                    if (getLogsErrorResponse.shouldRetry === true)
                        throw error;
                }
                if (shouldRetry(error) === false) {
                    common.logger.warn({
                        service: "rpc",
                        msg: `Failed ${request.method} request`,
                    });
                    throw error;
                }
                if (i === RETRY_COUNT) {
                    common.logger.warn({
                        service: "rpc",
                        msg: `Failed ${request.method} request after ${i + 1} attempts`,
                        error,
                    });
                    throw error;
                }
                const duration = BASE_DURATION * 2 ** i;
                common.logger.debug({
                    service: "rpc",
                    msg: `Failed ${request.method} request, retrying after ${duration} milliseconds`,
                    error,
                });
                await wait(duration);
            }
        }
    };
    const requestQueue = createQueue({
        frequency: network.maxRequestsPerSecond,
        concurrency,
        initialStart: true,
        browser: false,
        worker: async (task) => {
            common.metrics.ponder_rpc_request_lag.observe({ method: task.request.method, network: network.name }, task.stopClockLag());
            return await fetchRequest(task.request);
        },
    });
    return {
        request: (params) => {
            const stopClockLag = startClock();
            return requestQueue.add({ request: params, stopClockLag });
        },
    };
};
/**
 * @link https://github.com/wevm/viem/blob/main/src/utils/buildRequest.ts#L192
 */
function shouldRetry(error) {
    if ("code" in error && typeof error.code === "number") {
        // Invalid JSON
        if (error.code === ParseRpcError.code)
            return false;
        // Method does not exist
        if (error.code === MethodNotFoundRpcError.code)
            return false;
        // Method is not implemented
        if (error.code === MethodNotSupportedRpcError.code)
            return false;
        // Version of JSON-RPC protocol is not supported
        if (error.code === JsonRpcVersionUnsupportedError.code)
            return false;
        // eth_call reverted
        if (error.message.includes("revert"))
            return false;
    }
    if (error instanceof HttpRequestError && error.status) {
        // Method Not Allowed
        if (error.status === 405)
            return false;
        // Not Found
        if (error.status === 404)
            return false;
        // Not Implemented
        if (error.status === 501)
            return false;
        // HTTP Version Not Supported
        if (error.status === 505)
            return false;
    }
    return true;
}
//# sourceMappingURL=requestQueue.js.map