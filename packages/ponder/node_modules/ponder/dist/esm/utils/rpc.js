import { toLowerCase } from './lowercase.js';
import { BlockNotFoundError, TransactionReceiptNotFoundError, numberToHex, } from "viem";
/**
 * Helper function for "eth_getBlockByNumber" request.
 */
export const _eth_getBlockByNumber = (requestQueue, { blockNumber, blockTag, }) => requestQueue
    .request({
    method: "eth_getBlockByNumber",
    params: [
        typeof blockNumber === "number"
            ? numberToHex(blockNumber)
            : (blockNumber ?? blockTag),
        true,
    ],
})
    .then((_block) => {
    if (!_block)
        throw new BlockNotFoundError({
            blockNumber: (blockNumber ?? blockTag),
        });
    return _block;
});
/**
 * Helper function for "eth_getBlockByNumber" request.
 */
export const _eth_getBlockByHash = (requestQueue, { hash }) => requestQueue
    .request({
    method: "eth_getBlockByHash",
    params: [hash, true],
})
    .then((_block) => {
    if (!_block)
        throw new BlockNotFoundError({
            blockHash: hash,
        });
    return _block;
});
/**
 * Helper function for "eth_getLogs" rpc request.
 * Handles different error types and retries the request if applicable.
 */
export const _eth_getLogs = async (requestQueue, params) => {
    if ("blockHash" in params) {
        return requestQueue
            .request({
            method: "eth_getLogs",
            params: [
                {
                    blockHash: params.blockHash,
                    topics: params.topics,
                    address: params.address
                        ? Array.isArray(params.address)
                            ? params.address.map((a) => toLowerCase(a))
                            : toLowerCase(params.address)
                        : undefined,
                },
            ],
        })
            .then((l) => l);
    }
    return requestQueue
        .request({
        method: "eth_getLogs",
        params: [
            {
                fromBlock: typeof params.fromBlock === "number"
                    ? numberToHex(params.fromBlock)
                    : params.fromBlock,
                toBlock: typeof params.toBlock === "number"
                    ? numberToHex(params.toBlock)
                    : params.toBlock,
                topics: params.topics,
                address: params.address
                    ? Array.isArray(params.address)
                        ? params.address.map((a) => toLowerCase(a))
                        : toLowerCase(params.address)
                    : undefined,
            },
        ],
    })
        .then((l) => l);
};
/**
 * Helper function for "eth_getTransactionReceipt" request.
 */
export const _eth_getTransactionReceipt = (requestQueue, { hash }) => requestQueue
    .request({
    method: "eth_getTransactionReceipt",
    params: [hash],
})
    .then((receipt) => {
    if (!receipt)
        throw new TransactionReceiptNotFoundError({
            hash,
        });
    return receipt;
});
/**
 * Helper function for "eth_getBlockReceipts" request.
 */
export const _eth_getBlockReceipts = (requestQueue, { blockHash }) => requestQueue
    .request({
    method: "eth_getBlockReceipts",
    params: [blockHash],
})
    .then((receipts) => receipts);
/**
 * Helper function for "debug_traceBlockByNumber" request.
 */
export const _debug_traceBlockByNumber = (requestQueue, { blockNumber, }) => requestQueue
    .request({
    method: "debug_traceBlockByNumber",
    params: [
        typeof blockNumber === "number"
            ? numberToHex(blockNumber)
            : blockNumber,
        { tracer: "callTracer" },
    ],
})
    .then((traces) => {
    const result = [];
    let index = 0;
    // all traces that weren't included because the trace has an error
    // or the trace's parent has an error, mapped to the error string
    const failedTraces = new Map();
    const dfs = (frames, transactionHash, parentFrame) => {
        for (const frame of frames) {
            if (frame.error !== undefined) {
                failedTraces.set(frame, {
                    error: frame.error,
                    revertReason: frame.revertReason,
                });
            }
            else if (parentFrame && failedTraces.has(parentFrame)) {
                const error = failedTraces.get(parentFrame);
                frame.error = error.error;
                frame.revertReason = error.revertReason;
                failedTraces.set(frame, error);
            }
            // @ts-ignore
            frame.index = index;
            // @ts-ignore
            frame.subcalls = frame.calls?.length ?? 0;
            result.push({ trace: frame, transactionHash });
            index++;
            if (frame.calls) {
                dfs(frame.calls, transactionHash, frame);
            }
        }
    };
    for (const trace of traces) {
        index = 0;
        dfs([trace.result], trace.txHash, undefined);
    }
    return result;
});
/**
 * Helper function for "debug_traceBlockByHash" request.
 */
export const _debug_traceBlockByHash = (requestQueue, { hash, }) => requestQueue
    .request({
    method: "debug_traceBlockByHash",
    params: [hash, { tracer: "callTracer" }],
})
    .then((traces) => {
    const result = [];
    let index = 0;
    // all traces that weren't included because the trace has an error
    // or the trace's parent has an error, mapped to the error string
    const failedTraces = new Map();
    const dfs = (frames, transactionHash, parentFrame) => {
        for (const frame of frames) {
            if (frame.error !== undefined) {
                failedTraces.set(frame, {
                    error: frame.error,
                    revertReason: frame.revertReason,
                });
            }
            else if (parentFrame && failedTraces.has(parentFrame)) {
                const error = failedTraces.get(parentFrame);
                frame.error = error.error;
                frame.revertReason = error.revertReason;
                failedTraces.set(frame, error);
            }
            // @ts-ignore
            frame.index = index;
            // @ts-ignore
            frame.subcalls = frame.calls?.length ?? 0;
            result.push({ trace: frame, transactionHash });
            index++;
            if (frame.calls) {
                dfs(frame.calls, transactionHash, frame);
            }
        }
    };
    for (const trace of traces) {
        index = 0;
        dfs([trace.result], trace.txHash, undefined);
    }
    return result;
});
//# sourceMappingURL=rpc.js.map