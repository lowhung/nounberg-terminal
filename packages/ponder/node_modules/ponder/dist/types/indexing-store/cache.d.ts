import type { Common } from '../internal/common.js';
import type { Event, Schema, SchemaBuild } from '../internal/types.js';
import type { Drizzle } from '../types/db.js';
import { PGlite } from "@electric-sql/pglite";
import { type Table } from "drizzle-orm";
import type { PoolClient } from "pg";
export type IndexingCache = {
    /**
     * Returns true if the cache has an entry for `table` with `key`.
     */
    has: (params: {
        table: Table;
        key: object;
    }) => boolean;
    /**
     * Returns the entry for `table` with `key`.
     */
    get: (params: {
        table: Table;
        key: object;
        db: Drizzle<Schema>;
    }) => Row | null | Promise<Row | null>;
    /**
     * Sets the entry for `table` with `key` to `row`.
     */
    set: (params: {
        table: Table;
        key: object;
        row: Row;
        isUpdate: boolean;
    }) => Row;
    /**
     * Deletes the entry for `table` with `key`.
     */
    delete: (params: {
        table: Table;
        key: object;
        db: Drizzle<Schema>;
    }) => boolean | Promise<boolean>;
    /**
     * Writes all temporary data to the database.
     */
    flush: (params: {
        client: PoolClient | PGlite;
    }) => Promise<void>;
    /**
     * Predict and load rows that will be accessed in the next event batch.
     */
    prefetch: (params: {
        events: Event[];
        db: Drizzle<Schema>;
    }) => Promise<void>;
    /**
     * Remove spillover and buffer entries.
     */
    rollback: () => void;
    /**
     * Marks the cache as incomplete.
     */
    invalidate: () => void;
    /**
     * Deletes all entries from the cache.
     */
    clear: () => void;
    event: Event | undefined;
};
/**
 * Database row.
 *
 * @example
 * {
 *   "owner": "0x123",
 *   "spender": "0x456",
 *   "amount": 100n,
 * }
 */
export type Row = {
    [key: string]: unknown;
};
/**
 * Recorded database access pattern.
 *
 * @example
 * {
 *   "owner": ["args", "from"],
 *   "spender": ["log", "address"],
 * }
 */
export type ProfilePattern = {
    [key: string]: string[];
};
export declare const getCopyText: (table: Table, rows: Row[]) => string;
export declare const getCopyHelper: ({ client }: {
    client: PoolClient | PGlite;
}) => (table: Table, text: string, includeSchema?: boolean) => Promise<void>;
export declare const recoverBatchError: <T>(values: T[], callback: (values: T[]) => Promise<unknown>) => Promise<{
    status: "success";
} | {
    status: "error";
    error: Error;
    value: T;
}>;
export declare const createIndexingCache: ({ common, schemaBuild: { schema }, crashRecoveryCheckpoint, eventCount, }: {
    common: Common;
    schemaBuild: Pick<SchemaBuild, "schema">;
    crashRecoveryCheckpoint: string;
    eventCount: {
        [eventName: string]: number;
    };
}) => IndexingCache;
//# sourceMappingURL=cache.d.ts.map